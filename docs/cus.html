<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <link rel="stylesheet" type="text/css" href="qtstalker.css" media="screen">
  <script type="text/javascript" src="qtstalker.js">
 </script>
  <title>Qtstalker: Custom - CUS</title>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
</head>

<body>

<div id="content">

<div id="rightPanel">

<div id="version">
</div>

<div id="toc">
<hr>
<ul>
  <li><a href="index.html">Home</a></li>
  <li><a href="toc.html">Table of Contents</a></li>
</ul>
</div>

</div>

<h1><u>Indicators</u></h1>

<p></p>

<p>All indicators in Qtstalker are constructed using scripts. These scripts can
be written in any popular scripting language that can read / write to STDIN and
STDOUT. Languages like Perl, Python, PHP etc. The pre-installed scripts
provided are written in Perl. See the contributed "<a href="#examples">CUS
Examples Repository</a>" for examples. For a description of available
indicators for scripts see the <a href="indicatorreference.html">Indicator
Reference.</a> </p>

<p><br>
</p>

<h3>Basic Script Example</h3>

<p></p>

<p>Here is an example of a basic script using perl. There are 3 basic steps to
each script. </p>
<ol>
  <li>Turn on autoflush. Most scripting languages have this function. This is
    required by qtstalker in order to make sure all data being sent/received by
    qtstallker and the script are complete and not buffered.</li>
  <li>Create the indicators.</li>
  <li>Plot the desired indicators.</li>
</ol>

<p></p>

<p>Turn on autoflush.</p>

<p></p>

<p style="margin-left:4em">$|++;</p>

<p></p>

<p>Now we create a BARS indicator. Each indicator has a format. We consult the
indicator reference to determine the proper format and make the request. The
request to create an indicator is made to STDOUT. The request is a string in
the proper format to create a BARS indicator.</p>

<p></p>

<p>print STDOUT "INDICATOR,BARS,Bars,green,red,blue";</p>

<p></p>

<p>Each time we communicate with Qtstalker, a return code is returned from
STDIN. This lets the script know if what we requested was successful. A 0 is
returned on success and 1 on failure. If there was a failure then the script
should exit immediately. </p>

<p></p>

<p>$a = &lt;STDIN&gt;; </p>

<p></p>

<p>The return code is a string with a carraige return, so we strip off the
carraige return so we can do a comparison and act accordingly. In perl we use
the chomp function.</p>

<p></p>

<p>chomp($a); </p>

<p></p>

<p>Now we find out what the return code is. If failure we exit the script.</p>

<p></p>

<p>if ($a ne "0")</p>

<p>{</p>

<p>exit;</p>

<p>}</p>

<p></p>

<p>If we got this far then everything has been successful. Now that we have our
BARS indicator, we plot it. The next command tells Qtstalker to plot our BARS
indicator. Consult the Indicator API for the plot command format for
details.</p>

<p></p>

<p>print STDOUT "PLOT,Bars,C,red,Bar"; </p>

<p></p>

<p>Once again we have to check to see if our plot command was successful. The
procedure is the same as the above example.</p>

<p></p>

<p>$a = &lt;STDIN&gt;; </p>

<p>chomp($a);</p>

<p>if ($a ne "0")</p>

<p>{</p>

<p>exit;</p>

<p>}</p>

<p></p>

<p>If we are here then our script was a success. Almost any indicator can be
created in this manner. There are over a hundred indicators, and functions to
pass indicator data directly back and forth between scripts and Qtstalker so
that complex calculations can be performed. Consult the indicator API for
details.</p>

<p></p>

<h4><a name="examples" id="examples">CUS Examples Repository</a></h4>

<p></p>

<p>See the directories "misc/CUS_examples/" See the documentation and how to
contribute. </p>

<p></p>

<p></p>
</div>
</body>
</html>
